package view

use dom {*}
use reactive {*}
use style {*}

use core.js
use core.misc {*}
use core.conv
use core {
    tprintf
}

ElementMessageClass :: #distinct str
ElementMessageId :: #distinct str
ElementMessageAttr :: #distinct str
ElementMessageStyle :: #distinct str

class :: (class_: $T) -> ElementMessageClass {   
    return cast(ElementMessageClass, tprintf("{}", class_))
}

id :: (id_: $T) -> ElementMessageId {
    return cast(ElementMessageId, tprintf("{}", id_))
}

attr :: (attr_: $T) -> ElementMessageAttr {
    return cast(ElementMessageAttr, tprintf("{}", attr_))
}

style :: (style_: $T) -> ElementMessageStyle {
    return cast(ElementMessageStyle, tprintf("{}", style_))
}

view_select :: (el: js.Value, type: type_expr, targets_: $T) -> js.Value {
    use runtime.info
    if !info.struct_constructed_from(targets_.type, Signal) {
        switch type {
            case js.Value {
                *any_as(targets_, js.Value) |> append(el);
            }
            case ElementMessageId {
                el |> set_id(tprintf("{}", cast(str) *any_as(targets_, ElementMessageId)));
            }
            case ElementMessageClass {
                console_log("class!")
                classes := cast(str) *any_as(targets_, ElementMessageClass) |> str.split(' ');
                for class in classes {
                    el |> add_class(class);
                }
            }
            case ElementMessageAttr {
                attrs := cast(str) *any_as(targets_, ElementMessageAttr) |> str.split(' ');
                for attr in attrs {
                    key_val := tprintf("{}", attr) |> str.split('=');
                    el |> set_attr(key_val[0], key_val[1]);
                }
            }
            case ElementMessageStyle {
                styles := cast(str) *any_as(targets_, ElementMessageStyle) |> str.split(';');
                for style in styles {
                    key_val := tprintf("{}", style) |> str.split(':');
                    key := key_val[0] |> str.strip_whitespace();
                    val := key_val[1];
                    el |> set_style(key, key_val[1]);
                }
            }
            case #default {
                    el->call("insertAdjacentText", "beforeend", conv.format_va("{}", any.[targets_]));
            }

        }
    } else {
        reactor := get_dom() 
        |> create("span") 
        |> append(el)
        switch type {
            case Signal(i32) {
                    reactor |> react_inner(*any_as(targets_, Signal(i32)))
            }
            case Signal(str) {
                    reactor |> react_inner(*any_as(targets_, Signal(str)))
            }
        }
    }
    return el;
}

div :: #match {
    (args: ..any) -> js.Value {
        new_el := get_dom() 
        |> create("div")
        for arg in args {
            new_el |> view_select(arg.type, arg);
        }
        return new_el
    }
    (class := "", id := "", attr := "") -> ((args: any) -> js.Value) {
        return (args: any, [class, id, attr]) -> js.Value {
            new_el := get_dom()
            |> create("div")
            |> set_class(class)
            |> set_id(id)
            // |> grab(args)

            return new_el
        };
    }
}
