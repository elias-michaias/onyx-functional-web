package view

#load "./dom.onyx"
#load "./reactive.onyx"
#load "./style.onyx"

use dom {*}
use reactive {*}
use style {*}

use core.js
use core.misc {*}
use core.conv
use core {
    tprintf
}

ElementMessageClass :: #distinct str
ElementMessageId :: #distinct str
ElementMessageAttr :: #distinct str
ElementMessageStyle :: #distinct str

class :: (class_: $T) -> ElementMessageClass {   
    return cast(ElementMessageClass, tprintf("{}", class_))
}

id :: (id_: $T) -> ElementMessageId {
    return cast(ElementMessageId, tprintf("{}", id_))
}

attr :: (attr_: $T) -> ElementMessageAttr {
    return cast(ElementMessageAttr, tprintf("{}", attr_))
}

style :: (style_: $T) -> ElementMessageStyle {
    return cast(ElementMessageStyle, tprintf("{}", style_))
}

extend :: (el: js.Value, args: ..any) -> js.Value {
    for arg in args {
        el |> view_select(arg.type, arg);
    }
    return el;
}

view_select :: (el: js.Value, type: type_expr, targets_: $T) -> js.Value {
    use runtime.info
    if !info.struct_constructed_from(targets_.type, Signal) {
        switch type {
            case js.Value {
                *any_as(targets_, js.Value) |> append(el);
            }
            case ElementCollection {
                col := *any_as(targets_, ElementCollection);
                val := cast(js.Value) col;
                for i in val->length() {
                    val->index(i)->call("appendChild", el);
                }
            }
            case ElementMessageId {
                el |> set_id(tprintf("{}", cast(str) *any_as(targets_, ElementMessageId)));
            }
            case ElementMessageClass {
                console_log("class!")
                classes := cast(str) *any_as(targets_, ElementMessageClass) |> str.split(' ');
                for class in classes {
                    el |> add_class(class);
                }
            }
            case ElementMessageAttr {
                attrs := cast(str) *any_as(targets_, ElementMessageAttr) |> str.split(' ');
                for attr in attrs {
                    key_val := tprintf("{}", attr) |> str.split('=');
                    el |> set_attr(key_val[0], key_val[1]);
                }
            }
            case ElementMessageStyle {
                styles := cast(str) *any_as(targets_, ElementMessageStyle) |> str.split(';');
                for style in styles {
                    key_val := tprintf("{}", style) |> str.split(':');
                    key := key_val[0] |> str.strip_whitespace();
                    val := key_val[1];
                    el |> set_style(key, key_val[1]);
                }
            }
            case #type (js.Value) -> js.Value, #type (js.Value) -> void {
                proc := *any_as(targets_, #type (js.Value) -> js.Value)
                proc(el)
            }
            case #default {
                el->call("insertAdjacentText", "beforeend", conv.format_va("{}", any.[targets_]));
            }

        }
    } else {
        reactor := get_dom() 
        |> create("span") 
        |> append(el)
        switch type {
            case Signal(i8) {
                reactor |> react_inner(*any_as(targets_, Signal(i8)))
            }
            case Signal(i16) {
                reactor |> react_inner(*any_as(targets_, Signal(i16)))
            }
            case Signal(i32) {
                reactor |> react_inner(*any_as(targets_, Signal(i32)))
            }
            case Signal(i64) {
                reactor |> react_inner(*any_as(targets_, Signal(i64)))
            }
            case Signal(f32) {
                reactor |> react_inner(*any_as(targets_, Signal(f32)))
            }
            case Signal(f64) {
                reactor |> react_inner(*any_as(targets_, Signal(f64)))
            }
            case Signal(u8) {
                reactor |> react_inner(*any_as(targets_, Signal(u8)))
            }
            case Signal(u16) {
                reactor |> react_inner(*any_as(targets_, Signal(u16)))
            }
            case Signal(u32) {
                reactor |> react_inner(*any_as(targets_, Signal(u32)))
            }
            case Signal(u64) {
                reactor |> react_inner(*any_as(targets_, Signal(u64)))
            }
            case Signal(bool) {
                reactor |> react_inner(*any_as(targets_, Signal(bool)))
            }
            case Signal(str) {
                reactor |> react_inner(*any_as(targets_, Signal(str)))
            }
            case Signal(cstr) {
                reactor |> react_inner(*any_as(targets_, Signal(cstr)))
            }
            case Signal(dyn_str) {
                reactor |> react_inner(*any_as(targets_, Signal(dyn_str)))
            }
            case Signal(rawptr) {
                reactor |> react_inner(*any_as(targets_, Signal(rawptr)))
            }
            case Signal(any) {
                reactor |> react_inner(*any_as(targets_, Signal(any)))
            }
            case Signal(type_expr) {
                reactor |> react_inner(*any_as(targets_, Signal(type_expr)))
            }
        }
    }
    return el;
}
