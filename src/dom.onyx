package dom

use core.js
use core.conv
use core {
    tprintf
}


get_dom :: () => {
    return js.Global->get("document");
}

get_body :: () => {
    return get_dom()->get("body");
}

get_head :: () => {
    return get_dom()->get("head");
}

create :: (dom: js.Value, new_el: str = "div") -> js.Value {
    el := dom->call("createElement", new_el);
    return el;
}

remove :: (el: js.Value) {
    el->call("remove");
}

append :: (el: js.Value, target: js.Value) -> js.Value {
    target->call("appendChild", el);
    return el;
}

prepend :: (el: js.Value, target: js.Value) -> js.Value {
    target->call("prepend", el);
    return el;
}

grab :: (el: js.Value, target: js.Value) -> js.Value {
    el->call("appendChild", target);
    return el;
}

set_inner :: (el: js.Value, args: ..any) -> js.Value {
    result: dyn_str;
    defer delete(&result);
    
    for arg in args {
        conv.format_va(&result, "{}", any.[ arg ]);
    }

    el->set("innerHTML", cast(str) result);
    return el;
}

get_inner :: (el: js.Value) -> str {
    inner := el->get("innerHTML");
    return inner->as_str()->unwrap();
}

swap_inner :: (el: js.Value, target: js.Value) -> js.Value {
    el->set("innerHTML", target->get("innerHTML"));
    return el;
}

set_outer :: (el: js.Value, args: ..any) -> js.Value {
    result: dyn_str;
    defer delete(&result);
    
    for arg in args {
        conv.format_va(&result, "{}", any.[ arg ]);
    }

    el->set("outerHTML", cast(str) result);
    return el;
}

get_outer :: (el: js.Value) -> str {
    outer := el->get("outerHTML");
    return outer->as_str()->unwrap();
}

swap_outer :: (el: js.Value, target: js.Value) -> js.Value {
    el->set("outerHTML", target->get("outerHTML"));
    return el;
}

set_text :: (el: js.Value, args: ..any) -> js.Value {
    result: dyn_str;
    defer delete(&result);
    
    for arg in args {
        conv.format_va(&result, "{}", any.[ arg ]);
    }

    el->set("textContent", cast(str) result);
    return el;
}

get_text :: (el: js.Value) -> str {
    text := el->get("textContent");
    return text->as_str()->unwrap();
}

swap_text :: (el: js.Value, target: js.Value) -> js.Value {
    el->set("textContent", target->get("textContent"));
    return el;
}

query :: (dom: js.Value, new_el: str) -> js.Value {
    el := dom->call("querySelector", new_el);
    return el;
}

query_all :: (dom: js.Value, new_el: str) -> js.Value {
    el:= dom->call("querySelectorAll", new_el);
    return el;
}

batch :: (els: js.Value, fn: (js.Value) -> void) -> js.Value {
    for i in els->length() {
        fn(els->index(i));
    }
    return els;
}

// id {{{

        query_id :: (dom: js.Value, new_el: str) -> js.Value {
            el := dom->call("getElementById", new_el);
            return el;
        }

        set_id :: (el: js.Value, new_id: $T) -> js.Value {
            el->call("setAttribute", "id", tprintf("{}", new_id));
            return el;
        }

        remove_id :: (el: js.Value) -> js.Value {
            el->call("removeAttribute", "id");
            return el;
        }

        get_id :: (el: js.Value) -> str {
            id := el->get("id");
            return id->as_str()->unwrap();
        }
    
// id }}}

// class {{{

        query_class :: (dom: js.Value, new_el: str) -> js.Value {
            el := dom->call("querySelector", str.concat(context.allocator, ".", new_el));
            return el;
        }

        query_all_class :: (dom: js.Value, new_el: str) -> #auto {
            el := dom->call("getElementsByClassName", new_el);
            return el;
        }

        set_class :: (el: js.Value, new_class: $T) -> js.Value {
            el->call("setAttribute", "class", tprintf("{}", new_class));
            return el;
        }

        add_class :: (el: js.Value, new_class: $T) -> js.Value {
            el->get("classList")->call("add", tprintf("{}", new_class));
            return el;
        }

        remove_class :: (el: js.Value, new_class: $T) -> js.Value {
            el->get("classList")->call("remove", tprintf("{}", new_class));
            return el;
        }

        toggle_class :: (el: js.Value, new_class: $T) -> js.Value {
            el->get("classList")->call("toggle", tprintf("{}", new_class));
            return el;
        }

        get_class :: (el: js.Value) -> str {
                class := el->get("className");
                return class->as_str()->unwrap();
        }

// class }}}

// attr {{{

        query_attr :: (dom: js.Value, attr: $T, val: T) -> js.Value {
            new_val := tprintf("{}", val);
            new_attr := tprintf("{}", attr);
            input := str.concat(context.allocator, "[", new_attr, "=\"", new_val, "\"]");
            el := dom->call("querySelector", input);
            return el;
        }
        
        query_all_attr :: (dom: js.Value, attr: $T, val: T) -> js.Value {
            new_val := tprintf("{}", val);
            new_attr := tprintf("{}", attr);
            input := str.concat(context.allocator, "[", new_attr, "=\"", new_val, "\"]");
            el := dom->call("querySelectorAll", input);
            return el;
        }

        set_attr :: (el: js.Value, attr: str, val: $T) -> js.Value {
            el->call("setAttribute", attr, tprintf("{}", val));
            return el;
        }

        remove_attr :: (el: js.Value, attr: str) -> js.Value {
            el->call("removeAttribute", attr);
            return el;
        }

        get_attr :: (el: js.Value, attr: str) -> str {
            attribute := el->call("getAttribute", attr);
            return attribute->as_str()->unwrap();
        }

// attr }}}

// misc {{{

        alert :: (msg: any) {
            js.Global->call("alert", tprintf("{}", msg));
        }

        console_log :: (msg: $T) {
            js.Global->get("console")->call("log", tprintf("{}", msg));
        }

// misc }}}
