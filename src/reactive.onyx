package sword.reactive

#load "./dom.onyx"
use sword.dom {*}
use sword.style {*}

use core {*}
use core.misc {*}
use core.intrinsics.types {type_is_function}

// init {{{

Runtime :: struct {
    signal_values: [..] any;
    running_effect: ? u32;

    signal_subscribers: Map(u32, Set(u32));
    effects: [..] () -> void;

    effect_arena: alloc.arena.Arena;
}

reactive_runtime: Runtime;

#init () {
    r: Runtime;
    r.effect_arena = alloc.arena.make(context.allocator, 16 * 1024);
    reactive_runtime = r;
}

// init }}}

// reaction logic {{{

signal :: (value: $T) -> Signal(T) {
    reactive_runtime.signal_values->push(.{ data = alloc.on_heap(value), type = T });
    id := reactive_runtime.signal_values.length - 1;
    return Signal(T).{ &reactive_runtime, id };
}

effect :: (f: () -> void) => {
    reactive_runtime.effects->push(alloc.copy_closure(f, alloc.as_allocator(&reactive_runtime.effect_arena)));
    id := reactive_runtime.effects.length - 1;
    run_effect(id);
}

run_effect :: (effect_id: u32) {
    prev_running_effect := reactive_runtime.running_effect;
    reactive_runtime.running_effect = effect_id;
    id_effect := reactive_runtime.effects[effect_id];
    id_effect();
    reactive_runtime.running_effect = prev_running_effect;
}

memo :: (f: () -> $R) -> Signal(R) {
    output := f() |> signal()
    effect(([output, f]) => { 
        output->set(f())
    })
    return output
}

bind :: (el: js.Value, f: (js.Value) -> void) -> js.Value {
    effect(([f, el]) => { 
        f(el)
    })
    return el
}

// watch_clauses :: #match {
//     (el: js.Value, clauses: [] Pair(str, () -> bool)) -> js.Value {
//         for clause in clauses {
//             attrs := clause.first |> str.split(' ');
//             effect(([el, clause]) => { 
//                 if clause.second {
//                     for attr in attrs {
//                         key_val := tprintf("{}", attr) |> str.split('=');
//                         el |> set_attr(key_val[0], key_val[1]);
//                     }
//                 } else {
//                     for attr in attrs {
//                         key_val := tprintf("{}", attr) |> str.split('=');
//                         el |> remove_attr(key_val[0]);
//                     }
//                 }
//             })
//         } 
//         return el
//     }
// }

bind_class_if :: (el: js.Value, classlist: str, f: () -> bool) -> js.Value {
    output := f() |> signal()
    effect(([output, f]) => { 
        output->set(f())
    })
    effect(([output, el, classlist]) => { 
        classes := classlist |> str.split(' ')
        if output->get() {
            for class in classes do el |> add_class(class)
        } else {
            for class in classes do el |> remove_class(class)
        }
    })
    return el
}

bind_id_if :: (el: js.Value, id: str, f: () -> bool) -> js.Value {
    output := f() |> signal()
    effect(([output, f]) => { 
        output->set(f())
    })
    effect(([output, el, id]) => { 
        if output->get() {
            el->set("id", id)
        } else {
            el->set("id", "")
        }
    })
    return el
}

bind_attr_if :: (el: js.Value, attr_: str, f: () -> bool) -> js.Value {
    output := f() |> signal()
    effect(([output, f]) => { 
        output->set(f())
    })
    effect(([output, el, attr_]) => { 
        attrs := attr_ |> str.split(' ');
        if output->get() {
            for attr in attrs {
                key_val := tprintf("{}", attr) |> str.split('=');
                el |> set_attr(key_val[0], key_val[1]);
            }
        } else {
            for attr in attrs {
                key_val := tprintf("{}", attr) |> str.split('=');
                el |> remove_attr(key_val[0]);
            }
        }
    })
    return el
}

bind_style_if :: (el: js.Value, style_: str, f: () -> bool) -> js.Value {
    output := f() |> signal()
    effect(([output, f]) => { 
        output->set(f())
    })
    effect(([output, el, style_]) => { 
        styles := style_ |> str.split(';');
        if output->get() {
            for style in styles {
                key_val := tprintf("{}", style) |> str.split(':');
                key := key_val[0] |> str.strip_whitespace();
                val := key_val[1];
                el |> set_style(key, key_val[1]);
            }
        } else {
            for style in styles {
                key_val := tprintf("{}", style) |> str.split(':');
                key := key_val[0] |> str.strip_whitespace();
                val := key_val[1];
                el |> remove_style(key);
            }
        }
    })
    return el
}

Signal :: struct (T: type_expr) {
    cx: &Runtime;
    id: u32;
}

Signal.get :: (self: #Self) -> self.T {
    v := self.cx.signal_values[self.id];

    self.cx.running_effect->with([ef] {
        subs := self.cx.signal_subscribers->get_ptr_or_create(self.id);
        subs->insert(ef);
    });

    return *any_as(v, self.T); 
}

Signal.get_as_type :: (s: rawptr, type: type_expr) -> any {
    Untyped_Signal :: struct {
        cx: &Runtime;
        id: u32;
    }
    us := cast(&Untyped_Signal) s;
    us.cx.running_effect->with([ef] {
        subs := us.cx.signal_subscribers->get_ptr_or_create(us.id);
        subs->insert(ef);
    });
    return us.cx.signal_values[us.id];
}

Signal.set :: (self: #Self, value: self.T) {
    v := &self.cx.signal_values[self.id];
    if v.type != self.T do return;

    *cast(&self.T) v.data = value;

    if subs := self.cx.signal_subscribers->get_ptr(self.id); subs {
        listeners := subs->as_iter()
                         ->map(x => *x)
                         ->collect(context.temp_allocator);

        subs->clear();

        for listeners {
            run_effect(it);
        }
    }
}

// reaction logic }}}

// dom integration {{{

react_inner :: (el: js.Value, args_: ..any) -> js.Value {
    args := any_deep_copy(args_);
    effect(([el, args]) => {
        result: dyn_str;
        use runtime.info;

        for arg in args {
            if info.struct_constructed_from(arg.type, Signal) {
                signal_type := *cast(&type_expr) arg.type->info()->as_struct().parameters[0].data;
                conv.format_va(&result, "{}", any.[ Signal.get_as_type(arg.data, signal_type) ]);
            } else {
                conv.format_va(&result, "{}", any.[ arg ]);
            }
        }
        el->set("innerHTML", cast(str) result);
    });

    return el;
}

react_outer :: (el: js.Value, args_: ..any) -> js.Value {
    args := any_deep_copy(args_);
    effect(([el, args]) => {
        result: dyn_str;
        use runtime.info;

        for arg in args {
            if info.struct_constructed_from(arg.type, Signal) {
                signal_type := *cast(&type_expr) arg.type->info()->as_struct().parameters[0].data;
                conv.format_va(&result, "{}", any.[ Signal.get_as_type(arg.data, signal_type) ]);
            } else {
                conv.format_va(&result, "{}", any.[ arg ]);
            }
        }
        el->set("outerHTML", cast(str) result);
    });

    return el;
}

react_text :: (el: js.Value, args_: ..any) -> js.Value {
    args := any_deep_copy(args_);
    effect(([el, args]) => {
        result: dyn_str;
        use runtime.info;

        for arg in args {
            if info.struct_constructed_from(arg.type, Signal) {
                signal_type := *cast(&type_expr) arg.type->info()->as_struct().parameters[0].data;
                conv.format_va(&result, "{}", any.[ Signal.get_as_type(arg.data, signal_type) ]);
            } else {
                conv.format_va(&result, "{}", any.[ arg ]);
            }
        }
        el->set("textContent", cast(str) result);
    });

    return el;
}

// dom integration }}}
 
// signal helper methods {{{

    // increment and decrement {{{
    Signal(f32).decrement :: (self: #Self) {
        self->set(self->get() - 1.0)
    }

    Signal(f32).increment :: (self: #Self) {
        self->set(self->get() + 1.0)
    }

    Signal(f64).decrement :: (self: #Self) {
        self->set(self->get() - 1.0)
    }

    Signal(f64).increment :: (self: #Self) {
        self->set(self->get() + 1.0)
    }

    Signal(i16).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(i16).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(i32).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(i32).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(i64).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(i64).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(i8).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(i8).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(u16).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(u16).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(u32).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(u32).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(u64).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(u64).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }

    Signal(u8).decrement :: (self: #Self) {
        self->set(self->get() - 1)
    }

    Signal(u8).increment :: (self: #Self) {
        self->set(self->get() + 1)
    }
    // increment and decrement }}}

Signal(bool).toggle :: (self: #Self) {
    self->set(!self->get())
}

// signal helper methods }}}