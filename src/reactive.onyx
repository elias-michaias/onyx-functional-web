package reactive

#load "./dom.onyx"
use dom {*}

use core {*}
use core.misc {any_as}
use core.intrinsics.types {type_is_function}

// init {{{

Runtime :: struct {
    signal_values: [..] any;
    running_effect: ? u32;

    signal_subscribers: Map(u32, Set(u32));
    effects: [..] () -> void;

    effect_arena: alloc.arena.Arena;
}

reactive_runtime: Runtime;

#init () {
    r: Runtime;
    r.effect_arena = alloc.arena.make(context.allocator, 16 * 1024);
    reactive_runtime = r;
}

// init }}}

// reaction logic {{{

signal :: (value: $T) -> Signal(T) {
    reactive_runtime.signal_values->push(.{ data = alloc.on_heap(value), type = T });
    id := reactive_runtime.signal_values.length - 1;
    return Signal(T).{ &reactive_runtime, id };
}

effect :: (f: () -> void) {
    reactive_runtime.effects->push(alloc.copy_closure(f, alloc.as_allocator(&reactive_runtime.effect_arena)));
    id := reactive_runtime.effects.length - 1;

    run_effect(id);
}

run_effect :: (effect_id: u32) {
    prev_running_effect := reactive_runtime.running_effect;
    reactive_runtime.running_effect = effect_id;

    effect := reactive_runtime.effects[effect_id];
    effect();

    reactive_runtime.running_effect = prev_running_effect;
}


Signal :: struct (T: type_expr) {
    cx: &Runtime;
    id: u32;
}

Signal.get :: (self: #Self) -> self.T {
    v := self.cx.signal_values[self.id];

    self.cx.running_effect->with([ef] {
        subs := self.cx.signal_subscribers->get_ptr_or_create(self.id);
        subs->insert(ef);
    });

    return *any_as(v, self.T); 
}

Signal.get_as_type :: (s: rawptr, type: type_expr) -> any {
    Untyped_Signal :: struct {
        cx: &Runtime;
        id: u32;
    }
    us := cast(&Untyped_Signal) s;
    us.cx.running_effect->with([ef] {
        subs := us.cx.signal_subscribers->get_ptr_or_create(us.id);
        subs->insert(ef);
    });
    return us.cx.signal_values[us.id];
}

Signal.set :: (self: #Self, value: self.T) {
    v := &self.cx.signal_values[self.id];
    if v.type != self.T do return;

    *cast(&self.T) v.data = value;

    if subs := self.cx.signal_subscribers->get_ptr(self.id); subs {
        listeners := subs->as_iter()
                         ->map(x => *x)
                         ->collect(context.temp_allocator);

        subs->clear();

        for listeners {
            run_effect(it);
        }
    }
}

// reaction logic }}}

// dom integration {{{

// react_inner :: (el: js.Value, args: ..any) -> js.Value {
//     arglist: [];
//     use runtime.info;
//     for arg in args {
//         if info.struct_constructed_from(arg.type, Signal) {
//             arglist->push(arg);
//         }
//     }

//     effect(([arglist, el]) => {
//         result: dyn_str;
//         defer delete(&result);
    
//         use runtime.info;
//         for arg in args {
//             if info.struct_constructed_from(arg.type, Signal) {
//                 signal_type := *cast(&type_expr) arg.type->info()->as_struct().parameters[0].data;
//                 conv.format_va(&result, "{}", any.[ Signal.get_as_type(arg.data, signal_type) ]);
//             } else {
//                 conv.format_va(&result, "{}", any.[ arg ]);
//             }
//         }

//         el->set("innerHTML", cast(str) result);
//     });

//     return el;
// }

// react_outer :: (el: js.Value, signal: Signal($T)) -> js.Value {
//     effect(([signal, el]) => {
//         el |> set_outer(signal->get());
//     });
//     return el;
// }

// react_text :: (el: js.Value, signal: Signal($T)) -> js.Value {
//     effect(([signal, el]) => {
//         el |> set_text(signal->get());
//     });
//     return el;
// }

// dom integration }}}
 